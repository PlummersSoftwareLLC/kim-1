; VMBAS BASIC/VM PATCHES (typed in by Hans Otten 2 October 2023)
; 
; Version 1.0 
; - Adapted for KIM-1 TTY keyboard input
; - lowercase adapted to more conventional type (from SDTXT lowercase)
; - Visible Memory at $A000
; - moved beyond KB9 end (START at 4270)
;
; DOCUMENTATION
; ***** MODIFIED FOR KIM BASIC *****
; THIS PACKAGE ALLOWS THE VISIBLE MEMORY TO BE USED WITH MICRO-
; SOFT BASIC AS TERMINAL DISPLAY DEVICE AND A GRAPHICS DISPLAY
; DEVICE. A SLIGHTLY MODIFIED VERSION OF SDTXT IS USED FOR TEXT
; DISPLAY AND AN ABBREVIATED VERSION OF THE GRAPHICS PACKAGE IS
; USED FOR GRAPHICS.
;
; INTERFACE WITH BASIC IS AT TWO LEVELS. THE CALL TO THE KIM
; TTY PRINT ROUTINE IS REPLACED BY A CALL TO SDTXT WHICH MEANS
; THAT ALL PRINTED OUTPUT FROM BASIC GOES TO THE SCREEN. THE
; KEYBOARD ROUTINE SUPPLIED BY THE USER SHOULD ALSO CALL SDTXT
; SO THAT TYPED INPUT APPEARS ON THE SCREEN AS WELL. INTERFACE
; TO THE GRAPHICS ROUTINES IS THROUGH THE USR FUNCTION AND THE
; VARIABLE STORAGE AREA IN BASIC. THE ARGUMENT OF THE USR
; FUNCTION CALL SELECTS WHICH GRAPHICS ROUTINE IS TO BE USED.
; THE COORDINATE DATA USED BY THE GRAPHICS FUNCTIONS IS ASSUMED
; TO BE IN THE FIRST 4 ENTRIES OF THE VARIABLE TABLE AND IS
; ASSUMED TO BE INTEGER DATA. TO ESTABLISH THE COORDINATE NAMES
; AND INSURE THAT THEY ARE STORED FIRST IN THE VARIABLE TABLE,
; THE FOLLOWING BASIC STATEMENT MUST BE CODED AS PART OF THE
; USER'S PROGRAM:
;
;  1 X1%=0; Y1%=0; X2%=0; Y2%=0
;
; THE STATEMENT NUMBER 1 INSURES THAT IT WILL BE EXECUTED FIRST
; AND THAT X1%, Y1%, X2%, AND Y2% WILL APPEAR FIRST IN THE
; VARIABLE TABLE AND IN THE CORRECT ORDER. THE % SIGNS AFTER
; THE VARIABLE NAMES INDICATE THAT THEY ARE INTEGER VARIABLES
; AND MUST BE USED. THE ACTUAL NAME MAY BE CHANGED BUT
; CONFUSION IS MINIMIZED BY USING THE NAMES GIVEN. THE ORIGIN
; OF THE COORDINATE SYSTEM IS THE LOWER LEFT CORNER OF THE
; SCREEN. THE ALLOWABLE RANGE OF X IS 0 TO 319 INCLUSIVE AND
; THE Y RANGE IS 0 TO 199 INCLUSIVE. OUT OF RANGE COORDINATES
; WILL BE CORRECTED BY COMPUTING THEIR VALUE MODULO THE MAXIMUM
; VALUE PLUS 1. THE MODULUS COMPUTATION IS PRIMITIVE AND MAY BE
; SLOW HOWEVER. IF THE GRAPHICS ROUTINE MODIFIES ANY OF THE
; COORDINATES, THEY WILL BE MODIFIED IN BASIC'S VARIABLE TABLE
; AS WELL.
;
; THE USR FUNCTION CODES ARE AS BELOW:
;
; O CLEAR THE SCREEN AND SET THE TEXT CURSOR AT UPPER LEFT
;    CORNER OF THE SCREEN
; 1 POINT PLOT X1,Y1 WHITE DOT X1, Y1 NOT CHANGED
; 2 LINE PLOT FROM X1,Y1 TO X2,Y2 WHITE LINE
;   X2 COPIED INTO X1 AND Y2 COPIED INTO Y1 UPON RETURN
; 3 POINT PLOT X1,Y1 BLACK DOT X1, Y1 NOT CHANGED
; 4 LINE PLOT FROM X1,Y1 TO X2,y2 BLACK LINE (ERASE)
;   X2 COPIED INTO X1 AND Y2 COPIED INTO Y1 UPON RETURN
; 5 READ POINT AT X1,¥1 VALUE OF USR FUNCTION ON RETURN IS
;   THE STATE OF THE POINT O=BLACK 1=WHITE
; 6 CLEAR THE TEXT CURSOR FROM THE SCREEN
; 7 SET THE TEXT CURSOR ON THE SCREEN
;
; FOR TEXT OUTPUT ANYWHERE ON THE SCREEN THE POKE FUNCTION CAN
; BE USED TO DIRECTLY ALTER THE CURSOR POSITION. THE
; NUMBER IS KEPT IN LOCATION 228 (10) AND THE LINE NUMBER
; IS KEPT IN LOCATION 229. THE CHARACTER NUMBER RANGE IS 0 
; TO 52 INCLUSIVE AND THE LINE NUMBER RANGES FROM 0 T0 21
; INCLUSIVE. THE CHARACTER MATRIX IS 5 BY 7 IN A CHARACTER
; CELL OF 6 BY 9. LINE O CHARACTER 0 IS THE UPPER LEFT
; OF THE SCREEN AND COVERS X COORDINATES OF O TO 6 AND
; COORDINATES OF 191-199 INCLUSIVE.
; OUT OF RANGE LINE OR CHARACTER NUMBERS WILL BE CORRECTED
; AS WITH POINT COORDINATES.
; 
; NOTE THAT THE TEXT CURSOR SHOULD BE CLEARED FROM THE SCREEN
; BEFORE MOVING IT WITH POKES AND SHOULD BE SET AFTERWARDS.
; STANDARD BASIC PRINT STATEMENTS CAN BE USED FOR PLOTTING.
; IF SEMICOLONS ARE USED TO SUPPRESS CARRIAGE RETURN/LINEFEED
; NOTE THAT IF A CARRIAGE RETURN/LINE FEED IS PRINTED AND
; LINE NUMBER IS 21 THAT THE ENTIRE DISPLAY, GRAPHICS ALSO
; WILL BE SCROLLED UPWARD 9 SCAN LINES.
;
; EQUATES AND STORAGE
;

; Page number of Visible Memory

VMPAGE	=   $A0			; Change for other page number

NX 	=   320         	; NUMBER OF BITS IN A ROW
NY      =   200         	; NUMBER OF ROWS  
NPIX    =   NX*NY       	; NUMBER OF PIXELS
NLOC    =   8000        	; NUMBER OF VISIBLE LOCATIONS
CHHI    =   9           	; CHARACTER WINDOW HEIGHT
CHWID   =   6           	; CHARACTER WINDOW WIDTH
NCHR	=   320/CHWID		; NUMBER OF CHARACTERS PER LINE
NLIN    =   NLOC/40/CHHI 	; NUMBER OF TEXT LINES
NSCRL   =   (NLIN-1)*CHHI*40 	; NUMBER OF LOCATIONS TO SCROLL
NCLR    =   NLOC-NSCRL  	; NUMBER OF LOCATIONS TO CLEAR AFTER SCROLL
ANKB	=   $0200		; LOCATION OF KEYBOARD ROUTINE
CNTLC	=   $0203		; LOCATION OF TEST FOR CONTROL/C ROUTINE
;
;
; PAGE 0 STORAGE		; THIS IS THE ONLY RAM STORAGE USED BY THIS PROGRAM
;
; .= $$E3			  START BASE PROGRAM STORAGE PAST END OF
;	                          BASIC AREA

; PERMANENT STORAGE THAT MAY BE WIPED OUT BY EXITING TO 
; THE KIM MONITOR
;
VMORG	= 	$E3			; FIRST PAGE NUMBER OF VISIBLE MEMORY
CSRX	= 	VMORG + 1		; TEXT CURSOR CHARACTER NUMBER
CSRY	=   	CSRX + 1		; TEXT CURSOR LINE NUMBER

;
; TEMPORARY STORAGE THAT MAY BE WIPED OUT BY EXITING TO THE KIM 
; MONITOR
;
X1CORD  = 	CSRY + 1   		; COPY OF BASIC'S X1 COORDINATE
Y1CORD  = 	X1CORD + 2		; COPY OF BASIC'S Y1 COORDINATE
X2CORD  = 	Y1CORD + 2 		; COPY OF BASIC'S X2 COORDINATE
Y2CORD  =	X2CORD + 2		; COPY OF BASIC'S Y2 COORDINATE
TEMP	=   	Y2CORD + 2		; TEMPORARY STORAGE
BTPT	= 	TEMP + 2 		; BIT POINTER WITHIN BYTE
SAVE	= 	BTPT + 1		; DO NOT USE KIM'S SAVE BYTE!!!!
ADP1	= 	SAVE + 1		; ADDRESS POINTER 1
ADP2	= 	ADP1 + 2		; ADDRESS POINTER 2
DELTAX	= 	ADP2 + 2		; DELTA X FOR LINE DRAW
DELTAY	= 	DELTAX + 2		; DELTA Y FOR LINE DRAW
ACC	= 	DELTAY + 2		; ACCUMULATOR FOR LINE DRAW
XDIR	= 	ACC + 2			; X MOVEMENT DIRECTION, ZERO=+
YDIR	= 	XDIR + 1		; Y MOVEMENT DIRECTION, ZERO=+	
XCHFLG	=	YDIR + 1		; EXCHANGE X AND Y FLAG, EXCAHNE IF NOT 0
COLOR	= 	XCHFLG + 1		; COLOR OF LINE DRAW - 1 =M WHITE
DCNT1	= 	TEMP			; DOUBLE PRECISION COUNTER
MRGT1	= 	XCHFLG			; TEMPORARY STORAGE FOR MERGE

KB9OUTC  = 	$2A52		 	; KIM KB-9 out character 
KB9INCH	 = 	$2AE6		 	; KIM KB-9 in character (with hardware echo!) 
KB9INC2  = 	$2457 
KIMINCH	 = 	$1E5A		 	; KIM-1 in character (with hardware echo!) 

; INITIALIZATION ROUTINE
                .ORG $4270		; START IMMEDIATELY BEYOND BASIC
;
INIT:		CLD			; CLEAR DECIMAL
                LDX 	#$FF		; CLEAR STACK
                TXS			

                LDA 	#VMPAGE		; INITIALIZE LOCATION OF VISIBLE MEMORY
                STA	VMORG
                LDA 	#<(DISPCH) 	; SET USRLOC TO GO TO GRAPHICS DISPATCH					
                STA	$2040		
                LDA 	#>(DISPCH)	; 
                STA	$2041
;		
; Adaptations Hans Otten, October 2023 
;
; Patch KB-9 OUTCH 
;
                LDA 	#<(SDTXT)	 ; patch K1--08 Out character into KB-9	
                STA 	KB9OUTC			
                LDA	#>(SDTXT)
                STA 	KB9OUTC + 1
;		
; Patch KB-9 INCHAR 
;
                LDA 	#<(KIMIN)	 ; patch K1--08 iut character into KB-9	
                STA 	KB9INCH			
                LDA	#>(KIMIN)
                STA 	KB9INCH + 1
                LDA 	#<(KIMIN)	 ; patch K1--08 iut character into KB-9	
                STA 	KB9INC2			
                LDA	#>(KIMIN)
                STA 	KB9INC2 + 1
;
;
                LDA	#<(END+1)	; ADJUST BEGINNING OF BASIC PROGRAM AFTER END
                STA 	$40CE		; TO SKIP OVER GRAPHICS PACKAGE
                LDA	#>(END+1)
                STA	$40D0
                LDX	#7		; MOVE 7 BYTES INTO BASIC WHICH CAUSES 
INIT1:		LDA 	INTCOD,X	; QUESTION REGARDING TRIG FUCNTIONS TO BE
                STA 	$4136, X	; SKIPPED AND PRESERVES BASIC INITIZALIZATION
                DEX			; ROUTINE
                BPL 	INIT1
                LDA	#$0C		; CLEAR THE SCREEN AND PUT THE CURSOR AT 
                JSR 	SDTXT		; CHARACTER 0 LINE 0
                JMP	$4065		; ENTER BASIC
;
;
INTCOD:		LDX	#<(END+1)   	; INITIALIZATION CODE TO POKE INTO BASIC 
                LDY	#>(END+1)   	; INITIALIZATION ROUTINES
                JMP	$4183		 
;      
; KIM-1 in character, echo also on K-1008
;
KIMIN:		 JSR 	KIMINCH 	 ; get KIM-1 character	
                 JSR 	SDTXT		 ; echo on K-1008
                 RTS			
                 
; Subroutines KIM-1 INIT
;
; DISPATCH ROUTINE FROM A USR CALL
; THIS ROUTINE LOOKS AT THE ARGUMENT OF THE USR FUNCTION CALL
; AND DISPATCHESTO THE PROPER GRAPHICS ROUTINE.
; IT ALSO COPIES THE COORDINATES FROM THE VARIABLE AREA IN BASIC 
; TO PAGE 0 LOCATIONS BEFORE EXECUTING A GRAPHICS ROUTINE AND
; COPIES THEM BACK AFTER EXECUTING A GRAPHICS ROUTINE
;
DISPCH:		LDY	#2		; SET UP TO MOVE 4 COORDINATES TO PAGE 0
                LDX	#0
DISPC1:		LDA	($007A),Y	; GET HIGH BYTE OF AN INTEGER VARIABLE
                STA	X1CORD+1,X	; STORE IT IN PAGE 0
                INY
                LDA	($007A),Y	; GET LOW BYTE OF VARIABLE
                STA	X1CORD,X	; STORE IT IN PAGE 0
                TYA			; ADD 6 TO Y TO POINT TOT NEXT VARIABLE
                CLC			; IN BASIC'S VARIABLE TABLE
                ADC	#6
                TAY
                INX			; ADD 2 TO X TO POINT TO NEXT VARIABLE IN
                INX			; PAGE 0
                CPX	#8		; TEST IF MOVE IS COMPLETE
                BNE	DISPC1		; CONTINUE IF NOT
                JSR	CKCRD		; CORRECT IF NECESSARY	


; GET ARGUMENT OF USR CALL. CHECK FOR ALLOWABLE RANGE AND
; DISPATCH TO CORRECT GRAPHICS ROUTINE

                JSR 	GETARG		; GET LOW ARGUMENT IN A AND HIGH ARGUMENT
                                        ; IN Y
                LDA	$B1		; CHECK FOR LEGAL ARGUMENT
                                        ; UPPER BYTE MUST BE ZERO 
                BNE	ILLEGL		; GO RETURN FOR ILLEGAL ARGUMENT
                LDA	$B2		; TEST FOR RANGE OF 0 TO 7 INCLUSIVE
                CMP	#$7		; LOWER BYTE AND
                BCS	ILLEGL		; GO RETURN IF NOT IN RANGE
                JSR	VCTJSR		; DO A VECTOR JSR TO THE CORRESPONING 
                                        ; GRAPHICS ROUTINE
                TAY			; RETURN FUNCTION RESULT TO BASIC
                LDA	#0
                JSR 	PUTARG

; MOVE THE COORDINATES BACK TO BASIC
;
                LDY 	#2		; SET UP TO MOVE 4 COORDINATES BACK
                LDX	#0
DISPC2:		LDA	X1CORD+1,X	; GET HIGH BYTE OF AN INTEGER VARIABLE
                STA	($007A),Y	; STORE IT BACK IN BASIC
                INY
                LDA	X1CORD,X	; GET LOW BYTE OF THE VARIABLE
                STA	($007A),Y	; STORE IT BACK
                TYA			; ADD 6 TO Y TO POINT TOT NEXT VARIABLE
                CLC			; IN BASIC'S VARIABLE TABLE
                ADC	#6
                TAY
                INX			; ADD 2 TO X TO POINT TO NEXT VARIABLE IN
                INX			; PAGE 0
                CPX	#8		; TEST IF MOVE IS COMPLETE
                BNE	DISPC2		; CONTINUE IF NOT
DISPC3:		RTS			; RETURN TO BASIC		
                
ILLEGL:		JMP	DISPC3		; IMMEDIATE RETURN ON ILLEGAL ARGUMENT
                                        ; CAN BE CHANGED TO GO TO ANOTHER USR
                                        ; ROUTINE

GETARG:		JMP	($0006)		; GO TO GET ARGUMENT FUNCTION IN BASIC

PUTARG:		JMP	($0008)		; GO TO PUT ARGUMENT FUNCTION IN BASIC

VCTJSR:		ASL 	A		; DOUBLE THE ARGUMENT VALUE
                TAX			; USE AS INDEX INTO DISPATCH TABLE
                LDA	DSPTAB+1,X	; TRANSFER TABLE ENTRY TO THE STACK
                PHA
                LDA	DSPTAB,X
                PHA
                RTS			; JUMP TO  THE ADDRESS ON TOP OF THE 
                                        ; STACK
                                        ; RETURNS TO THE CALLER OF THIS ROUTINE

DSPTAB:		.WORD	CLEAR-1		; 0 ADDRESS OF CLEAR ROUTINE								
                .WORD	STPIX-1		; 1 ADDRESS OF SET PIXEL ROUTINE
                .WORD	DRAW-1		; 2 ADDRESS OF DRAW LINE ROUTINE
                .WORD	CLPIX-1		; 3 ADDRESS OF CLEAR PIXEL ROUTINE
                .WORD	ERASE-1		; 4 ADDRESS OF ERASE LINE ROUTINE
                .WORD	RDPIX-1		; 5 ADDRESS OF READ PIXEL ROUTINE
                .WORD	CSRCLR-1	; 6 ADDRESS OF CLEAR CURSOR ROUTINE
                .WORD	CSRSET-1	; 7 ADDRESS OF INSERT CURSOR ROUTINE

; DOCUMENTATION OF ABBREVIATED GRAPHICS PACKAGE
; THIS PACKAGE PROVIDES FUNDAMENTAL GRAPHICS ORIENTED
; SUBROUTINES NEEDED FOR EFFECTIVE USE OF THE VISIBLE MEMORY AS
; A GRAPHIC DISPLAY DEVICE WITH MICROSOFT BASIC. THE ROUTINES
; INCLUDED ARE AS FOLLOWS:
;   CLEAR - CLEARS THE ENTIRE VISIBLE MEMORY AS DEFINED BY
;           NPIX/8
;   PIXADR- RETURNS BYTE AND BIT ADDRESS OF PIXEL AT X1CORD,
;           Y1CORD
;   CKCRD - PERFORM A RANGE CHECK ON ALL COORDINATES
;   STPIX - SET PIXEL AT X1CORD,Y1CORD TO A ONE (WHITE DOT)
;   CLPIX - CLEAR PIXEL AT X1CORD,Y1CORD TO ZERO (BLACK DOT)
;   RDPIX - COPY THE STATE OF THE PIXEL AT X1CORD,Y1CORD INTO
;           THE ACCUMULATOR
;   DRAW  - DRAW THE BEST STRAIGHT LINE FROM X1CORD,Y1CORD
;           TO X2CORD,Y2CORD. X2CORD,Y2CORD COPIED TO
;           X1CORD,Y1CORD AFTER DRAWING
;   ERASE - SAME AS DRAW EXCEPT A BLACK LINE IS DRAWN
;
; ALL SUBROUTINES DEPEND ON ONE OR TWO PAIRS OF COORDINATES.
; EACH COORDINATE IS A DOUBLE PRECISION, UNSIGNED NUMBER WITH
; THE LOW BYTE FIRST (I.E. LIKE MEMORY ADDRESSES IN THE 6502)
; THE ORIGIN OF THE COORDINATE SYSTEM IS AT THE LOWER LEFT
; CORNER OF THE SCREEN THEREFORE THE ENITRE SCREEN IS IN THE
; FIRST QUADRANT. ALLOWABLE RANGE OF THE X COORDINATE IS O TO
; 319 (DECIMAL) AND THE RANGE OF THE Y COORDINATE IS O TO 199.


; CLEAR ENTIRE SCREEN ROUTINE
; USES BOTH INDICES AND ADP1

CLEAR:		LDY 	#0 		; INITIALIZE ADDRESS POINTER
                STY 	ADP2 		; AND ZERO INDEX Y
                LDA 	VMORG
                STA 	ADP2+1
                LDA 	#>(NPIX/8)      ; SET COUNT OF BYTES TO CLEAR
                STA 	DCNT1+1
                LDA 	#<(NPIX/8)
                STA 	DCNT1
                JMP 	FCLR 	 	; GO DO CLEAR AND RETURN
        
; PIXADR - BYTE AND BIT ADDRESS OF A PIXEL
; PIXADR - FIND THE BYTE ADDRESS AND BIT NUMBER OF PIXEL AT
;          X1CORD,Y1CORD
; PUTS BYTE ADDRESS IN ADP1 AND BIT NUMBER (BIT 0 IS LEFTMOST)
; IN BTPT.
; DOES NOT CHECK MAGNITUDE OF COORDINATES FOR MAXIMUM SPEED
; PRESERVES X AND Y REGISTERS, DESTROYS A
; BYTE ADDRESS = VMORG*256+(199-Y1CORD)*40+INT(XCORD/8)
; BIT ADDRESS = REM(XCORD/8)
; OPTIMIZED FOR SPEED THEREFORE CALLS TO A DOUBLE SHIFT ROUTINE
; ARE NOT DONE
PIXADR:	 	LDA 	X1CORD 		; COMPUTE BIT ADDRESS FIRST
                STA 	ADP1 		; ALSO TRANSFER X1CORD TO ADP1
                AND 	#$07		; + WHICH IS SIMPLY THE LOW 3 BITS OF X
                STA 	BTPT
                LDA 	X1CORD+1 	; FINISH TRANSFERRING X1CORD TO ADP1
                STA 	ADP1+1
                LSR 	ADP1+1 		; DOUBLE SHIFT ADP1 RIGHT 3 TO GET
                ROR 	ADP1 		; INT(XCORD/8 )
                LSR 	ADP1+1
                ROR 	ADP1
                LSR 	ADP1+1
                ROR 	ADP1
                LDA 	#199 		; TRANSFER (199-Y1CORD) TO ADP2
                SEC 			; AND TEMPORARY STORAGE
                SBC 	Y1CORD
                STA 	ADP2
                STA 	TEMP
                LDA 	#0
                SBC 	Y1CORD+1
                STA 	ADP2+1
                STA 	TEMP+1
                ASL 	ADP2 		; COMPUTE 40*(199-Y1CORD)
                ROL 	ADP2+1 		;  2*(199-Y1CORD)
                ASL 	ADP2
                ROL 	ADP2+1 		;  4*(199-Y1CORD)
                LDA 	ADP2 		;  ADD IN TEMPORARY SAVE OF (199-Y1CORD)
                CLC 			;  TO MAKE 5*(199-Y1CORD)
                ADC 	TEMP
                STA 	ADP2
                LDA 	ADP2+1
                ADC 	TEMP+1
                STA 	ADP2+1 		; 5*(199-Y1CORD)
                ASL 	ADP2 		; 10*(199-Y1CORD)
                ROL 	ADP2+1
                ASL 	ADP2 		; 20#(199-Y1CORD)
                ROL 	ADP2+1
                ASL 	ADP2 		; 40*(199-Y1CORD)
                ROL 	ADP2+1
                LDA 	ADP2 		; ADD IN INT(X1CORD/8) COMPUTED EARLIER
                CLC
                ADC 	ADP1
                STA 	ADP1
                LDA 	ADP2+1
                ADC 	ADP1+1
                ADC 	VMORG 		; ADD IN VMORG*256
                STA 	ADP1+1 		; FINAL RESULT
                RTS 			; RETURN
                
; ‘INDIVIDUAL PIXEL SUBROUTINES'
; STPIX - SETS THE PIXEL AT X1CORD,Y1CORD TO A ONE (WHITE DOT)
; DOES NOT ALTER X1CORD OR Y1CORD
; ASSUMES IN RANGE CORRDINATES

STPIX:	 	JSR 	PIXADR 		; GET BYTE ADDRESS AND BIT NUMBER OF PIXEL
                                        ; INTO ADP1
                LDY 	BTPT 		; GET BIT NUMBER IN Y
                LDA 	MSKTB1,Y 	; GET A BYTE WITH THAT BIT =1, OTHERS =0
                LDY 	#0 		; ZERO Y
                ORA 	(ADP1),Y 	; COMBINE THE BIT WITH THE ADDRESSED VM
                STA 	(ADP1),Y 	; BYTE
                RTS 			; RETURN

; CLPIX - CLEARS THE PIXEL AT X1CORD,Y1CORD TO A ZERO (BLACK DOT)
; DOES NOT ALTER X1CORD OR Y1CORD
; ASSUMES IN RANGE COORDINATES

CLPIX:		JSR 	PIXADR 		; GET BYTE ADDRESS AND BIT NUMBER OF PIXEL
                                        ; INTO ADP1
                LDY 	BTPT 		; GET BIT NUMBER IN Y
                LDA 	MSKTB2,Y 	; GET A BYTE WITH THAT BIT =0, OTHERS =1
                LDY 	#0 		; ZERO Y
                AND 	(ADP1),Y 	; REMOVE THE BIT FROM THE ADDRESSED VM
                STA 	(ADP1),Y 	; BYTE
                RTS 			; AND RETURN

; RDPIX — READS THE PIXEL AT X1CORD,YICORD AND SETS A TO ALL
; ZEROES IF IT IS A ZERO OR TO ONE IF IT IS A ONE.
; LOW BYTE OF ADP1 IS EQUAL TO A ON RETURN
; DOES NOT ALTER X1CORD OR Y1CORD
; ASSUMES IN RANGE CORRDINATES

RDPIX:	 	JSR 	PIXADR 		; GET BYTE AND BIT ADDRESS OF PIXEL
                LDY 	#0 		; GET ADDRESSED BYTE FROM VM
                LDA 	(ADP1),Y
                LDY 	BTPT 		; GET BIT NUMBER IN Y
                AND 	MSKTB1,Y 	; CLEAR ALL BUT ADDRESSED BIT
                BEQ 	RDPIX1 		; SKIP AHEAD IF IT WAS A ZERO
                LDA 	#$01 		; SET TO 01 IF IT WAS A ONE
RDPIX1:		RTS 			; RETURN

; MASK TABLES FOR INDIVIDUAL PIXEL SUBROUTINES
; MSKTB1 IS A TABLE OF 1 BITS CORRESPONDING TO BIT NUMBERS
; MSKTB2 IS A TABLE OF 0 BITS CORRESPONDING TO BIT NUMBERS

MSKTB1:	 	.BYTE 	$80,$40,$20,$10
                .BYTE 	$08,$04,$02,$01
MSKTB2:	  	.BYTE 	$7F,$BF,$DF,$EF
                .BYTE 	$F7,$FB,$FD,$FE

; WRPIX - SETS THE PIXEL AT X1CORD,YICORD ACCORDING TO THE STATUS
; OF BIT O (RIGHTMOST) OF A
; DOES NOT ALTER X1CORD OR Y1CORD
; ASSUMES IN RANGE CORRDINATES

WRPIX:		AND 	#$01 		; TEST LOW BIT OF A
                BEQ 	CLPIX 		; GO WRITE A ZERO IF IT IS ZERO
                BNE 	STPIX 		; OTHERWISE WRITE A ONE
                
; ‘COORDINATE CHECK AND CORRECT ROUTINE!
; CHECKS ALL COORDINATES TO VERIFY THAT THEY ARE IN THE
; PROPER RANGE. IF NOT, THEY ARE REPLACED BY A VALUE
; MODULO THE MAXIMUM VALUE+1.
; NOTE THAT THESE ROUTINES CAN BE VERY SLOW WHEN CORRECTIONS ARE
; NECESSARY BECAUSE A BRUTE FORCE DIVISON ROUTINE IS USED TO
; THE MODULUS.

CKCRD:	  	LDX 	#X1CORD-X1CORD 		; CHECK X1CORD
                LDY 	#XLIMIT-LIMTAB
                JSR 	CK
                LDX 	#X2CORD-X1CORD 		; CHECK X2CORD
                JSR 	CK
                LDX 	#Y1CORD-X1CORD 		; CHECK Y1CORD
                LDY 	#YLIMIT-LIMTAB
                JSR 	CK
                LDX 	Y2CORD-X1CORD		; CHECK Y2CORD
                JMP 	CK 			; AND RETURN


CK: 		LDA 	X1CORD+1,X 		; CHECK UPPER BYTE
                CMP 	LIMTAB+1,Y 		; AGAINST UPPER BYTE OF LIMIT
                BCC 	CK4			; OK IF LESS THAN UPPER BYTE OF LIMIT
                BEQ 	CK3 			; GO CHECK LOWER BYTE IF EQUAL TO
                                                ; UPPER BYTE OF LIMIT
CK2: 		LDA 	X1CORD, X 		; SUBTRACT THE LIMIT
                SEC 				; LOWER BYTE FIRST
                SBC 	LIMTAB,Y
                STA 	X1CORD,X
                LDA 	X1CORD+1,X
                SBC 	LIMTAB+1,Y
                STA 	X1CORD+1,X
                JMP 	CK 			; AND THEN GO CHECK RANGE AGAIN
CK3: 		LDA 	X1CORD,X 		; CHECK LOWER BYTE OF X
                CMP 	LIMTAB,Y
                BCS 	CK2			; GO ADJUST IF TOO LARGE
CK4: 		RTS 				; RETURN

LIMTAB: 					; TABLE OF LIMITS
XLIMIT: 	.WORD NX
YLIMIT: 	.WORD NY

; LINE DRAWING ROUTINES
; DRAW - DRAW THE BEST STRAIGHT LINE FROM XiCORD,YICORD TO
; X2CORD, Y2CORD.
; X2CORD,Y2CORD COPIED TO X1CORD,Y1CORD AFTER DRAWING
; USES AN ALGORITHM THAT REQUIRES NO MULTIPLICATION OR DIVISion

ERASE:	 	LDA 	#$00 		; SET LINE COLOR TO BLACK
                BEQ 	DRAW1 		; GO DRAW THE LINE
DRAW:	 	LDA 	#$FF 		; SET LINE COLOR TO WHITE
DRAW1:	 	STA 	COLOR


; COMPUTE SIGN AND MAGNITUDE OF DELTA X = X2-X1
; PUT MAGNITUDE IN DELTAX AND SIGN IN XDIR

                LDA 	#0 		; FIRST ZERO XDIR
                STA 	XDIR
                LDA 	X2CORD 		; NEXT COMPUTE TWOS COMPLEMENT DIFFERE
                SEC
                SBC	X1CORD
                STA	DELTAX
                LDA	X2CORD+1
                SBC	X1CORD+1
                STA	DELTAX+1
                BPL	DRAW2 		; SKIP AHEAD IF DIFFERENCE IS POSITIVE
                DEC	XDIR 		; SET XDIR TO -1
                SEC			; NEGATE DELTAX
                LDA	#0
                SBC	DELTAX
                STA	DELTAX
                LDA 	#0
                SBC 	DELTAX+1
                STA 	DELTAX+1
                
; COMPUTE SIGN AND MAGNITUDE OF DELTA Y = Y2-Y1
; PUT MAGNITUDE IN DELTAY AND SIGN IN YDIR

DRAW2:	 	LDA 	#0 		; FIRST ZERO YDIR
                STA 	YDIR
                LDA 	Y2CORD 		; NEXT COMPUTE TWOS COMPLEMENT DIFFERE
                SEC
                SBC 	Y1CORD
                STA 	DELTAY
                LDA 	Y2CORD+1
                SBC 	Y1CORD+1
                STA 	DELTAY+1
                BPL 	DRAW3 		; SKIP AHEAD IF DIFFERENCE IS POSITIVE
                DEC 	YDIR 		; SET YDIR TO -1
                SEC 			; NEGATE DELTAX
                LDA 	#0
                SBC 	DELTAY
                STA 	DELTAY
                LDA	#0
                SBC 	DELTAY+1
                STA 	DELTAY+1
        
; DETERMINE IF DELTAY IS LARGER THAN DELTAX
; IF SO, EXCHANGE DELTAY AND DELTAX AND SET XCHFLG NONZERO
; ALSO INITIALIZE ACC TO DELTAX
; PUT A DOT AT THE INITIAL ENdPOINT

DRAW3:		LDA 	#0 		; FIRST ZERO XCHFLG
                STA 	XCHFLG
                LDA 	DELTAY 		; COMPARE DELTAY WITH DELTAX
                SEC
                SBC 	DELTAX
                LDA 	DELTAY+1
                SBC 	DELTAX+1 
                BCC 	DRAW4 		; SKIP EXCHANGE IF DELTAX IS GREATER THAN
                                        ; DELTAY
                LDX 	DELTAY 		; EXCHANGE DELTAX AND DELTAY
                LDA 	DELTAX
                STA 	DELTAY
                STX 	DELTAX
                LDX 	DELTAY+1
                LDA 	DELTAX+1
                STA 	DELTAY+1
                STX 	DELTAX+1
                DEC 	XCHFLG 		; SET XCHFLG TO -1
DRAW4:	 	LDA 	DELTAX 		; INITIALIZE ACC TO DELTAX
                STA 	ACC
                LDA 	DELTAX+1
                STA 	ACC+1
                LDA 	COLOR 		; PUT A DOT AT THE INITIAL ENDPOINT
                JSR 	WRPIX 		; X1CORD,Y1CORD

; HEAD OF MAIN DRAWING LOOP
; TEST IF DONE

DRAW45:	 	LDA 	XCHFLG 		; TEST IF X AND Y EXCHANGED
                BNE 	DRAW5 		; JUMP AHEAD IF SO
                LDA 	X1CORD 		; TEST FOR X1CORD=X2CORD
                CMP 	X2CORD
                BNE 	DRAW7		; GO FOR ANOTHER ITERATION IF NOT
                LDA 	X1CORD+1
                CMP 	X2CORD+1
                BNE 	DRAW7 		; GO FOR ANOTHER ITERATION IF NOT
                BEQ 	DRAW6 		; GO RETURN IF SO
DRAW5:	 	LDA 	Y1CORD 		; TEST FOR Y1CORD=Y2CORD
                CMP 	Y2CORD
                BNE 	DRAW7 		; GO FOR ANOTHER INTERATION IF NOT
                LDA 	Y1CORD+1
                CMP 	Y2CORD+1
                BNE 	DRAW7 		; GO FOR ANOTHER INTERATION IF NOT
DRAW6:	 	RTS 			;RETURN

; DO A CLACULATION TO DETERMINE IF ONE OR BOTH AXES ARE TO BE
; BUMPED (INCREMENTED OR DECREMENTED ACCORDING TO XDIR AND YDIR)
; AND DO THE BUMPING

DRAW7:	 	LDA 	XCHFLG 		; TEST IF X AND Y EXCHANGED
                BNE 	DRAW8 		; JUMP IF SO
                JSR 	BMPX 		; BUMP X IF NOT
                JMP 	DRAW9
DRAW8:	  	JSR 	BMPY 		; BUMP Y IF SO
DRAW9:  	JSR 	SBDY 		; SUBTRACT DY FROM ACC TWICE
                JSR 	SBDY
                BPL 	DRAW12 		; SKIP AHEAD IF ACC IS NOT NEGATIVE
                LDA 	XCHFLG 		; TEST IF X AND Y EXCHANGED
                BNE 	DRAW10 		; JUMP IF SO
                JSR 	BMPY 		; BUMP Y IF NOT
                JMP 	DRAW11
DRAW10: 	JSR 	BMPX 		; BUMP X IF SO
DRAW11: 	JSR 	ADDX 		; ADD DX TO ACC TWICE
                JSR 	ADDX

DRAW12: 	LDA 	COLOR 		; OUTPUT THE NEW POINT
                JSR 	WRPIX
                JMP 	DRAW45		; GO TEST IF DONE

; SUBROUTINES FOR DRAW

SBDY:		LDA 	ACC 		; SUBTRACT DELTAY FROM ACC AND PUT RESULT
                SEC 				; IN ACC
                SBC 	DELTAY
                STA 	ACC
                LDA 	ACC+1
                SBC 	DELTAY+1
                STA 	ACC+1
                RTS


ADDX:	 	LDA 	ACC			; ADD DELTAX TO ACC AND PUT RESULT IN ACC
                CLC
                ADC 	DELTAX
                STA 	ACC
                LDA 	ACC+1
                ADC 	DELTAX+1
                STA 	ACC+1
                RTS


BMPX:	 	LDA 	XDIR 		; BUMP X1CORD BY +1 OR -1 ACCORDING TO
                BNE 	BMPX2 		; XDIR
                INC 	X1CORD 		; DOUBLE INCREMENT X1CORD IF XDIR=0
                BNE 	BMPX1
                INC 	X1CORD+1
BMPX1:	 	RTS
BMPX2:		LDA 	X1CORD	 	; DOUBLE DECREMENT X1CORD IF XDIR <> 0
                BNE 	BMPX3
                DEC 	X1CORD+1
BMPX3:		DEC 	X1CORD
                                RTS
 
 
BMPY:	 	LDA 	YDIR 		; BUMP Y1ICORD BY +1 OR -~1 ACCORDING TO
                BNE 	BMPY2	 	; YDIR
                INC 	Y1CORD 		; DOUBLE INCREMENT Y1ICORD IF YDIR=0
                BNE 	BMPY1
                INC 	Y1CORD+1
BMPY1:	 	RTS
BMPY2:		LDA 	Y1CORD 	; DOUBLE DECREMENT Y1CORD IF YDIR >  
                BNE 	BMPY3
                DEC 	Y1CORD+1
BMPY3:	 	DEC 	Y1CORD
                RTS
                
;  'SIMPLIFIED VISABLE MEMORY TEXT DISPLAY SUBROUTINE'
;        THIS SUBROUTINE TURNS THE VISABLE MEMORY INTO A DATA DISPLAY
;        TERMINAL (GLASS TELETYPE).
;        CHARACTER SET IS 96 FULL ASCII UPPER AND LOWER CASE.
;        CHARACTER MATRIX IS 5 BY 7 SET INTO A 6 BY 9 RECTANGLE.
;        LOWER CASE IS REPRESENTED AS SMALL (5 BY 5) CAPITALS.
;        SCREEN CAPACITY IS 22 LINES OF 53 CHARACTERS FOR FULL SCREEN.
;        CURSOR IS A NON-BLINKING UNDERLINE.
;        CONTROL CODES RECOGNIZED:

;        CR     $0D         SETS CURSOR TO LEFT SCREEN EDGE
;        LF     $0A         MOVES CURSOR DOWN ONE LINE, SCROLLS
;                           DISPLAY UP ONE LINE IF ALREADY ON BOTTOM
;                           LINE
;        BACK ARROW   $5F   MOVES CURSOR ONE CHARACTER LEFT, DOES
;                           NOTHING IF ALREADY AT LEFT SCREEN EDGE
;        FF     $0C         CLEARS SCREEN AND PUTS CURSOR AT TOP LEFT
;                           OF SCREEN, SHOULD BE CALLED FOR
;                           INITIALIZATION

;        ALL OTHER CONTROL CODES IGNORED.
;        ENTER WITH CHARACTER TO BE DISPLAYED IN A.
; 		 CSRX SHOULD CONTAIN THE CHARACTER NUMBER
; 		 CSRY SHOULD CONTAIN THE LINE NUMBER
; 		 CSRX AND CSRY ARE CHECK FOR IN RANGE VALUES AND CORRECTED IF
; 		 NECESSARY

;        ******************************************************
;		 *                                                    *		
;        *     VMORG MUST BE SET BEFORE CALLING SDTXT         *
;		 *                                                    *		
;        ******************************************************

SDTXT:  	PHA                	; SAVE INPUT
                JSR 	CKCUSR		; CHECK AND CORRECT CURSOR SETTING
                LDA    	#0          	; CLEAR UPPER ADP2
                STA    	ADP2+1
                PLA
                PHA			; GET INPUT BACK
                AND    	#$7F        	; INSURE 7 BIT ASCII INPUT
                SEC
                SBC    	#$20       	; TEST IF A CONTROL CHARACTER
                BMI    	SDTX10      	; JUMP IF SO
                CMP	#$5F-$20	; TEST IF BACK ARROW (UNDRLINE)
                BEQ	SDTX10		; JUMP IF SO

;        CALCULATE TABLE ADDRESS FOR CHAR SHAPE AND PUT IT INTO ADPL

SDTXT1: 	STA    	ADP2         	; SAVE CHARACTER CODE IN ADP2
                JSR    	SADP2L       	; COMPUTE 8*CHARACTER CODE IN ADP2
                JSR    	SADP2L
                JSR    	SADP2L
                EOR    	#$FF         	; NEGATE CHARACTER CODE
                SEC    	             	; SUBSTRACT CHARACTER CODE FROM ADP2 AND
                ADC    	ADP2         	; PUT RESULT IN ADP1 FOR A FINAL RESULT OF
                STA    	ADP1         	; 7*CHARACTER CODE
                LDA    	ADP2+1
                ADC    	#$FF
                STA    	ADP1+1
                LDA    	ADP1         	; ADD IN ORIGIN OF CHARACTER TABLE
                CLC	
                ADC    	#<CHTB
                STA    	ADP1
                LDA    	ADP1+1
                ADC    	#>CHTB
                STA    	ADP1+1       	; ADP1 NOW HAS ADDRESS OF TOP ROW OF
                                            ; CHARACTER SHAPE
                                        
;        COMPUTE BYTE AND BIT ADDRESS OF FIRST SCAN LINE OF
;        CHARACTER AT CURSOR POSITION

                JSR    CSRTAD       	; COMPUTE BYTE AND BIT ADDRESSES OF FIRST
                                            ; SCAN LINE OF CHARACTER AT CURSOR POS.

;        SCAN OUT THE 7 CHARACTER ROWS

                LDY    #0          	; INITIALIZE Y INDEX=FONT TABLE POINTER
SDTX2:          LDA    (ADP1),Y    	; GET A DOT ROW FROM THE FONT TABLE
                JSR    MERGE       	; MERGE IT WITH GRAPHIC MEMORY AT (ADP2)
                JSR    DN1SCN      	; ADD 40 TO ADP2 TO MOVE DOWN ONE SCAN
                                           ; LINE IN GRAPHIC MEMORY
                INY                	; BUMP UP POINTER INTO FONT TABLE
                CPY    #7          	; TEST IF DONE
                BNE    SDTX2       	; GO DO NEXT SCAN LINE IF NOT
                LDA    CSRX        	; DO A CURSOR RIGHT
                CMP    #NCHR-1     	; TEST IF LAST CHARACTER ON THE LINE
                BPL    SDTX3       	; SKIP CURSOR RIGHT IF SO
                JSR    CSRCLR      	; CLEAR OLD CURSOR
                INC    CSRX        	; MOVE CURSOR ONE POSITION RIGHT
SDTX3:  	JMP    SDTXRT      	; GO INSERT CURSOR, RESTORE REGISTERS,
                                             ; AND RETURN

;        INTERPRET CONTROL CODES

SDTX10: 	CMP 	#$ED		; TEST IF CR	ED == 0D-$20
                BEQ 	SDTXCR 		; JUMP IF SO
                CMP 	#$EA     	; TEST IF LF	EA == 0A-$20
                BEQ 	SDTXLF 		; JUMP IF SO
                CMP 	#$3F 		; TEST IF BACK ARROW (UNDERLINE) 5F-$20
                BEQ 	SDTXCL 		; JUMP IF SO
                CMP 	#$D4 		; TEST IF FF    D4 == 0C-$20
                BEQ 	SDTXFF 		; JUMP IF SO
                JMP 	SDTXRT 		; GO RETURN IF UNRECOGNIZABLE CONTROL

SDTXCR: 	JSR 	CSRCLR  	; CARRIAGE RETURN, FIRST CLEAR CURSOR
                LDA 	#0 		; ZERO CURSOR HORIZONTAL POSITION
                STA 	CSRX
                JMP 	SDTXRT 		; GO SET CURSOR AND RETURN

SDTXCL: 	JSR 	CSRCLR 		; CURSOR LEFT, FIRST CLEAR CURSOR
                LDA 	CSRX 		; GET CURSOR HORIZONTAL POSITION
                CMP 	#0 			; TEST IF AGAINST LEFT EDGE
                BEQ 	SDTX20 		; SKIP UPDATE IF SO
                DEC 	CSRX 		; OTHERWISE DECREMENT CURSOR X POSITION
SDTX20: 	JMP 	SDTXRT 		; GO SET CURSOR AND RETURN

SDTXFF: 	JSR 	CLEAR 		; CLEAR THE SCREEN
                LDA 	#0
                STA 	CSRX 		; PUT CURSOR IN UPPER LEFT CORNER
                STA 	CSRY
                JMP 	SDTXRT 		; GO SET CURSOR AND RETURN

SDTXLF: 	JSR 	CSRCLR 		; LINE FEED, FIRST CLEAR CURSOR
                LDA 	CSRY 		; GET CURRENT LINE POSITION
                CMP 	#NLIN-1 	; TEST IF AT BOTTOM OF SCREEN
                BPL 	SDTX40 		; GO SCROLL IF SO
                INC 	CSRY 		; INCREMENT LINE NUMBER IF NOT AT BOTTOM
                BNE 	SDTXRT 		; GO INSERT CURSOR AND RETURN
SDTX40: 	LDA 	#0 		; SET UP ADDRESS POINTERS FOR MOVE
                STA 	ADP2 		; ADP1 = SOURCE FOR MOVE = FIRST BYTE
                LDA 	VMORG 		; SECOND LINE OF TEXT
                STA 	ADP2+1 		; ADP2 = DESTINATION FOR MOVE = FIRST BYTE
                CLC 			; IN VISIBLE MEMORY
                ADC 	#>(CHHI*40)
                STA 	ADP1+1
                LDA 	#<(CHHI*40)
                STA 	ADP1
                LDA 	#<(NSCRL) 	; SET NUMBER OF LOCATIONS TO MOVE
                STA 	DCNT1 		; LOW PART
                LDA 	#>(NSCRL) 	; HIGH PART
                STA 	DCNT1+1
                JSR 	FMOVE		; EXECUTE MOVE USING AN OPTIMIZED, HIGH
                                        ; SPEED MEMORY MOVE ROUTINE

                                        ; CLEAR LAST LINE OF TEXT
                LDA 	#<(NSCRL)       ; SET ADDRESS POINTER
                STA 	ADP2 		; LOW BYTE
                LDA 	#>(NSCRL)
                CLC
                ADC 	VMORG
                STA 	ADP2+1 		; HIGH BYTE
                LDA 	#<NCLR  	; SET LOW BYTE OF CLEAR COUNT
                STA 	DCNT1
                LDA 	#>NCLR 		; SET HIGH BYTE OF CLEAR COUNT
                STA 	DCNT1+1
                JSR 	FCLR 		; CLEAR THE DESIGNATED AREA

; NO EFFECTIVE CHANGE IN CURSOR POSITION

SDTXRT:		JSR 	CSRSET 		; RETURN SEQUENCE, INSERT CURSOR
                PLA 			; RESTORE INPUT FROM THE STACK
                RTS 			; RETURN
                
; SUBROUTINES FOR SDTXT!
; COMPUTE ADDRESS OF BYTE CONTAINING LAST SCAN LINE OF
; CHARACTER AT CURSOR POSITION
; ADDRESS = CSRTAD+(CHHI-1)*40 | SINCE CHHI IS A CONSTANT 9,
; (CHHI-1)*40=320
; BTPT HOLDS BIT ADDRESS, O=LEFTMOST

CSRBAD: 	JSR 	CSRTAD 		; COMPUTE ADDRESS OF TOP OF CHARACTER CELL
                                        ; FIRST
                LDA 	ADP2 		; ADD 320 TO RESULT = 8 SCAN LINES
                CLC
                ADC 	#<(320)
                STA 	ADP2
                LDA 	ADP2+1
                ADC 	#>(320)
                STA 	ADP2+1
                RTS

; SET CURSOR AT CURRENT POSITION

CSRSET: 	JSR 	CKCUSR 		; VERIFY LEGAL CURSOR COORDINATES
                JSR 	CSRBAD 		; GET BYTE AND BIT ADDRESS OF CURSOR
                LDA 	#$F8 		; DATA = UNDERLINE CURSOR
CSRST1: 	JMP 	MERGE 		; MERGE CURSOR WITH GRAPHIC MEMORY
                                        ; AND RETURN

; CLEAR CURSOR AT CURRENT POSITION

CSRCLR:		JSR 	CKCUSR 		; VERIFY LEGAL CURSOR COORDINATES
                JSR 	CSRBAD 		; GET BYTE AND BIT ADDRESS OF CURSOR
                LDA 	#0 		; DATA = BLANK DOT ROW
                JMP 	MERGE 		; REMOVE DOT ROW FROM GRAPHIC MEMORY
                                        ; AND RETURN

; SHIFT ADP2 LEFT ONE BIT POSITION

SADP2L:		ASL 	ADP2
                ROL 	ADP2+1
                RTS

; MOVE DOWN ONE SCAN LINE DOUBLE ADDS 40 TO ADP2

DN1SCN: 	LDA 	ADP2 		; ADD 40 TO LOW BYTE
                CLC
                ADC 	#40
                STA 	ADP2
                BCC 	DN1SC1		; EXTEND CARRY INTO UPPER BYTE
                INC 	ADP2+1
DN1SC1: 	RTS 			; RETURN

; COMPUTE BYTE ADDRESS CONTAINING FIRST SCAN LINE OF
; CHARACTER AT CURSOR POSITION AND PUT IN ADP2
; BIT ADDRESS (BIT 0 IS LEFTMOST) AT BTPT
; BYTE ADDRESS =VMORG*256+CHHI*40*CSRY+INT (CSRX*6/8 )
; SINCE CHHI IS A CONSTANT 9, THEN CHHI#*40=360
; BIT ADDRESS=REM(CSRX*5/8 )

CSRTAD:		LDA 	#0 		; ZERO UPPER ADP2
                STA 	ADP2+1
                LDA 	CSRY 		; FIRST COMPUTE 360*CSRY
                ASL	A 		;  COMPUTE 9*CSRY DIRECTLY IN A
                ASL	A
                ASL	A
                ADC 	CSRY
                STA 	ADP2 		;  STORE 9*CSRY IN LOWER ADP2
                JSR 	SADP2L 		;  18*CSRY IN ADP2
                JSR 	SADP2L 		;  36*CSRY IN ADP2
                ADC 	ADP2 		;  ADD IN 9*CSRY TO MAKE 45*CSRY
                STA 	ADP2
                LDA 	#0
                ADC 	ADP2+1
                STA 	ADP2+1 		;  45*CSRY IN ADP2
                JSR 	SADP2L 		;  9O*CSRY IN ADP2
                JSR 	SADP2L 		;  180*CSRY IN ADP2
                JSR 	SADP2L 		;  360*CSRY IN ADP2
                LDA 	CSRX 		; NEXT COMPUTE 6*CSRX WHICH IS A 9 BIT
                ASL	A 		; VALUE
                ADC 	CSRX
                ASL	A
                STA 	BTPT 		;  SAVE RESULT TEMPORARILY
                ROR	A 		;  DIVIDE BY 8 AND TRUNCATE FOR INT
                LSR	A 		;  FUNCTION
                LSR	A 		;  NOW HAVE INT(CSRX*6/8)
                CLC 			; DOUBLE ADD TO ADP2
                ADC 	ADP2
                STA 	ADP2
                LDA 	ADP2+1
                ADC 	VMORG 		; ADD IN VMORG*256
                STA 	ADP2+1 		; FINISHED WITH ADP2
                LDA 	BTPT 		; COMPUTE REM(CSRX*6/8) WHICH IS LOW 3
                AND 	#7 		; BITS OF CSRX*6
                STA 	BTPT 		; KEEP IN BTPT
                RTS 			; FINISHED

; CHECK CSRX AND CSRY FOR LEGAL VALUES. IF ILLEGAL, COMPUTE
; THEIR VALUE MOD THEIR MAXIMUM VALUE

CKCUSR: 	LDA 	CSRX 		; GET CHARACTER NUMBER
                CMP 	#NCHR 		; COMPARE WITH MAXIMUM CHARACTER NUMBER
                BCC 	CKCSR1 		; JUMP AHEAD IF OK
                SBC 	#NCHR 		; SUBTRACT MAXIMUM FROM IT IF TOO BIG
                STA 	CSRX 		; SAVE UPDATED
                JMP 	CKCUSR 		; GO TRY AGAIN
CKCSR1: 	LDA 	CSRY 		; GET LINE NUMBER
                CMP 	#NLIN 		; COMPARE WITH MAXIMUM LINE NUMBER
                BCC 	CKCSR2 		; GO RETURN TF OK
                SBC 	#NLIN 		; SUBTRACT MAXIMUM FROM IT IF TOO BIG
                STA 	CSRY 		; SAVE UPDATED
                JMP 	CKCSR1 		; GO TRY AGAIN
CKCSR2: 	RTS 			; RETURN

; MERGE A ROW OF 5 DOTS WITH GRAPHIC MEMORY STARTING AT BYTE
; ADDRESS AND BIT NUMBER IN ADP2 AND BIPT
; 5 DOTS TO MERGE LEFT JUSTIFIED IN A
; PRESERVES X AND Y

MERGE:	 	STA 	MRGT1		; SAVE INPUT DATA
                TYA 			; SAVE Y
                PHA
                LDY 	BTPT 		; OPEN UP A 5 BIT WINDOW IN GRAPHIC MEMORY
                LDA 	MERGT,Y 	; LEFT BITS
                LDY 	#0 		; ZERO Y
                AND 	(ADP2),Y
                STA 	(ADP2),Y
                LDY 	BTPT
                LDA 	MERGT+8,Y	; RIGHT BITS
                LDY 	#1
                AND 	(ADP2),Y
                STA 	(ADP2),Y
                LDA 	MRGT1 		; SHIFT DATA RIGHT TO LINE UP LEFTMOST
                LDY 	BTPT		; DATA BIT WITH LEFTMOST GRAPHIC FIELD
                BEQ 	MERGE2		; SHIFT BTPT TIMES
MERGE1: 	LSR	A
                DEY
                BNE 	MERGE1
MERGE2: 	ORA 	(ADP2),Y 	; OVERLAY WITH GRAPHIC MEMORY
                STA 	(ADP2),Y
                LDA 	#8 		; SHIFT DATA LEFT TO LINE UP RIGHTMOST
                SEC 			; DATA BIT WITH RIGHTMOST GRAPHIC FIELD
                SBC 	BTPT 		; SHIFT (8-BTPT) TIMES
                TAY
                LDA 	MRGT1
MERGE3: 	ASL	A
                DEY
                BNE 	MERGE3
                INY
                ORA 	(ADP2),Y 	; OVERLAY WITH GRAPHIC MEMORY
                STA 	(ADP2),Y
                PLA 			; RESTORE Y
                TAY
                RTS 			; RETURN
                
MERGT:	 	.BYTE 	$07,$83,$C1,$E0	; TABLE OF MASKS FOR OPENING UP
                .BYTE 	$F0,$F8,$FC,$FE	; A 5 BIT WINDOW ANYWHERE
                .BYTE 	$FF,$FF,$FF,$FF	; IN GRAPHIC MEMORY
                .BYTE 	$7F,$3F,$1F,$0F

; FAST MEMORY MOVE ROUTINE
; ENTER WITH SOURCE ADDRESS IN ADPT1 AND DESTINATION ADDRESS IN
; ADPT2 AND MOVE COUNT (DOUBLE PRECISION) IN DCNT1.
; MOVE PROCEEDS FROM LOW TO HIGH ADDRESSES AT APPROXIMATELY 16US
; PER BYTE.
; EXIT WITH ADDRESS POINTERS AND COUNT IN UNKNOWN STATE.
; PRESERVES X AND Y REGISTERS.

FMOVE:  	TXA 			; SAVE X AND Y ON THE STACK
                PHA
                TYA
                PHA
FMOVE1: 	DEC 	DCNT1+1 	; TEST IF LESS THAN 256 LEFT TO MC
                BMI 	FMOVE3 		; JUMP TO FINAL MOVE IF SO
                LDY 	#0 		; MOVE A BLOCK OF 256 BYTES QUICKL
FMOVE2: 	LDA 	(ADP1),Y 	; TWO BYTES AT A TIME
                STA 	(ADP2),Y
                INY
                LDA 	(ADP1),Y
                STA 	(ADP2) ,Y
                INY
                BNE 	FMOVE2 		; CONTINUE UNTIL DONE
                INC 	ADP1+1 		; BUMP ADDRESS POINTERS TO NEXT P#
                INC 	ADP2+1
                JMP 	FMOVE1 		; GO MOVE NEXT PAGE
FMOVE3: 	LDX 	DCNT1 		; GET REMAINING BYTE COUNT INTO X
FMOVE4: 	LDA 	(ADP1),Y 	; MOVE A BYTE
                STA 	(ADP2),Y
                INY
                DEX
                BNE 	FMOVE4 		; CONTINUE UNTIL DONE
                PLA 			; RESTORE INDEX REGISTERS
                TAY
                PLA
                TAX
                RTS 			; AND RETURN

 ; FAST MEMORY CLEAR ROUTINE
 ; ENTER WITH ADDRESS OF BLOCK TO CLEAR IN ADP2 AND CLEAI
 ; IN DCNT1.
 ; EXIT WITH ADDRESS POINTERS AND COUNT IN UNKNOWN STATE
 ; PRESERVES X AND Y REGISTERS

FCLR:	 	TYA 			; SAVE Y	
                PHA
FCLR1:  	LDY 	#0
                DEC 	DCNT1+1 	; TEST IF LESS THAN 256 LEFT TO MC
                BMI 	FCLR3 		; JUMP TO FINAL CLEAR IF SO
                TYA 			; CLEAR A BLOCK OF 256 QUICKLY
FCLR2:	 	STA 	(ADP2),Y 	; CLEAR A BYTE
                INY
                BNE 	FCLR2
                INC 	ADP2+1		; BUMP ADDRESS POINTER TO NEXT PAC
                JMP 	FCLR1 		; GO CLEAR NEXT PAGE
FCLR3:	 	TYA 			; CLEAR REMAINING PARTIAL PAGE
FCLR4:	 	STA 	(ADP2),Y
                INY
                DEC 	DCNT1
                BNE 	FCLR4
                PLA 			; RESTORE Y
                TAY
                RTS 			; RETURN

;        CHARACTER FONT TABLE
;        ENTRIES IN ORDER STARTING AT ASCII BLANK
;        96 ENTRIES
;        EACH ENTRY CONTAINS 7 BYTES
;        7 BYTES ARE CHARACTER MATRIX, TOP ROW FIRST, LEFTMOST DOT
;        IS LEFTMOST IN BYTE
;        LOWER CASE FONT IS SMALL UPPER CASE, 5 BY 5 MATRIX

CHTB:    .BYTE  $00,$00,$00    		; BLANK
         .BYTE  $00,$00,$00,$00
         .BYTE  $20,$20,$20    		; !
         .BYTE  $20,$20,$00,$20
         .BYTE  $50,$50,$50    		; "
         .BYTE  $00,$00,$00,$00
         .BYTE  $50,$50,$F8    ; #
         .BYTE  $50,$F8,$50,$50
         .BYTE  $20,$78,$A0    ; $
         .BYTE  $70,$28,$F0,$20
         .BYTE  $C8,$C8,$10    ; %
         .BYTE  $20,$40,$98,$98
         .BYTE  $40,$A0,$A0    ; &
         .BYTE  $40,$A8,$90,$68
         .BYTE  $30,$30,$30    ; '
         .BYTE  $00,$00,$00,$00
         .BYTE  $20,$40,$40    ; (
         .BYTE  $40,$40,$40,$20
         .BYTE  $20,$10,$10    ; )
         .BYTE  $10,$10,$10,$20
         .BYTE  $20,$A8,$70    ; *
         .BYTE  $20,$70,$A8,$20
         .BYTE  $00,$20,$20    ; +
         .BYTE  $F8,$20,$20,$00
         .BYTE  $00,$00,$00    ; ,
         .BYTE  $30,$30,$10,$20
         .BYTE  $00,$00,$00    ; -
         .BYTE  $F8,$00,$00,$00
         .BYTE  $00,$00,$00    ; .
         .BYTE  $00,$00,$30,$30
         .BYTE  $08,$08,$10    ; /
         .BYTE  $20,$40,$80,$80
         .BYTE  $60,$90,$90    ; 0
         .BYTE  $90,$90,$90,$60
         .BYTE  $20,$60,$20    ; 1
         .BYTE  $20,$20,$20,$70
         .BYTE  $70,$88,$10    ; 2
         .BYTE  $20,$40,$80,$F8
         .BYTE  $70,$88,$08    ; 3
         .BYTE  $30,$08,$88,$70
         .BYTE  $10,$30,$50    ; 4
         .BYTE  $90,$F8,$10,$10
         .BYTE  $F8,$80,$F0    ; 5
         .BYTE  $08,$08,$08,$F0
         .BYTE  $70,$80,$80    ; 6
         .BYTE  $F0,$88,$88,$70
         .BYTE  $F8,$08,$10    ; 7
         .BYTE  $20,$40,$80,$80
         .BYTE  $70,$88,$88    ; 8
         .BYTE  $70,$88,$88,$70
         .BYTE  $70,$88,$88    ; 9
         .BYTE  $78,$08,$08,$70
         .BYTE  $30,$30,$00    ; :
         .BYTE  $00,$00,$30,$30
         .BYTE  $30,$30,$00    ; ;
         .BYTE  $30,$30,$10,$20
         .BYTE  $10,$20,$40    ; LESS THAN
         .BYTE  $80,$40,$20,$10
         .BYTE  $00,$00,$F8    ; =
         .BYTE  $00,$F8,$00,$00
         .BYTE  $40,$20,$10    ; GREATER THAN
         .BYTE  $08,$10,$20,$40
         .BYTE  $70,$88,$08    ; ?
         .BYTE  $10,$20,$00,$20
         .BYTE  $70,$88,$08    ; @
         .BYTE  $68,$A8,$A8,$D0
         .BYTE  $20,$50,$88    ; A
         .BYTE  $88,$F8,$88,$88
         .BYTE  $F0,$48,$48    ; B
         .BYTE  $70,$48,$48,$F0
         .BYTE  $70,$88,$80    ; C
         .BYTE  $80,$80,$88,$70
         .BYTE  $F0,$48,$48    ; D
         .BYTE  $48,$48,$48,$F0
         .BYTE  $F8,$80,$80    ; E
         .BYTE  $F0,$80,$80,$F8
         .BYTE  $F8,$80,$80    ; F
         .BYTE  $F0,$80,$80,$80
         .BYTE  $70,$88,$80    ; G
         .BYTE  $B8,$88,$88,$70
         .BYTE  $88,$88,$88    ; H
         .BYTE  $F8,$88,$88,$88
         .BYTE  $70,$20,$20    ; I
         .BYTE  $20,$20,$20,$70
         .BYTE  $38,$10,$10    ; J
         .BYTE  $10,$10,$90,$60
         .BYTE  $88,$90,$A0    ; K
         .BYTE  $C0,$A0,$90,$88
         .BYTE  $80,$80,$80    ; L
         .BYTE  $80,$80,$80,$F8
         .BYTE  $88,$D8,$A8    ; M
         .BYTE  $A8,$88,$88,$88
         .BYTE  $88,$88,$C8    ; N
         .BYTE  $A8,$98,$88,$88
         .BYTE  $70,$88,$88    ; O
         .BYTE  $88,$88,$88,$70
         .BYTE  $F0,$88,$88    ; P
         .BYTE  $F0,$80,$80,$80
         .BYTE  $70,$88,$88    ; Q
         .BYTE  $88,$A8,$90,$68
         .BYTE  $F0,$88,$88    ; R
         .BYTE  $F0,$A0,$90,$88
         .BYTE  $78,$80,$80    ; S
         .BYTE  $70,$08,$08,$F0
         .BYTE  $F8,$20,$20    ; T
         .BYTE  $20,$20,$20,$20
         .BYTE  $88,$88,$88    ; U
         .BYTE  $88,$88,$88,$70
         .BYTE  $88,$88,$88    ; V
         .BYTE  $50,$50,$20,$20
         .BYTE  $88,$88,$88    ; W
         .BYTE  $A8,$A8,$D8,$88
         .BYTE  $88,$88,$50    ; X
         .BYTE  $20,$50,$88,$88
         .BYTE  $88,$88,$50    ; Y
         .BYTE  $20,$20,$20,$20
         .BYTE  $F8,$08,$10    ; Z
         .BYTE  $20,$40,$80,$F8
         .BYTE  $70,$40,$40    ; LEFT BRACKET
         .BYTE  $40,$40,$40,$70
         .BYTE  $80,$80,$40    ; BACKSLASH
         .BYTE  $20,$10,$08,$08
         .BYTE  $70,$10,$10    ; RIGHT BRACKET
         .BYTE  $10,$10,$10,$70
         .BYTE  $20,$50,$88    ; CARROT
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$00,$00    ; UNDERLINE
         .BYTE  $00,$00,$00,$F8
         .BYTE  $C0,$60,$30    ; GRAVE ACCENT
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$60,$10  	; A (LC)
         .BYTE  $70,$90,$90,$68
         .BYTE  $80,$80,$F0    ; B (LC)
         .BYTE  $88,$88,$88,$F0
         .BYTE  $00,$00,$78    ; C (LC)
         .BYTE  $80,$80,$80,$78
         .BYTE  $08,$08,$78    ; D (LC)
         .BYTE  $88,$88,$88,$78
         .BYTE  $00,$00,$70    ; E (LC)
         .BYTE  $88,$F0,$80,$78
         .BYTE  $30,$40,$40    ; F (LC)
         .BYTE  $E0,$40,$40,$40
         .BYTE  $00,$70,$88    ; G (LC)
         .BYTE  $98,$68,$08,$70
         .BYTE  $80,$80,$B0    ; H (LC)
         .BYTE  $C8,$88,$88,$88
         .BYTE  $20,$00,$20    ; I (LC)
         .BYTE  $20,$20,$20,$70
         .BYTE  $10,$00,$10    ; J (LC)
         .BYTE  $10,$10,$90,$60
         .BYTE  $80,$80,$90    ; K (LC)
         .BYTE  $A0,$C0,$A0,$90
         .BYTE  $60,$20,$20    ; L (LC)
         .BYTE  $20,$20,$20,$70
         .BYTE  $00,$00,$D0    ; M (LC)
         .BYTE  $A8,$A8,$A8,$A8
         .BYTE  $00,$00,$B0    ; N (LC)
         .BYTE  $C8,$88,$88,$88
         .BYTE  $00,$00,$70    ; O (LC)
         .BYTE  $88,$88,$88,$70
         .BYTE  $00,$00,$F0   ; P (LC)
         .BYTE  $88,$F0,$80,$80
         .BYTE  $00,$00,$78  ; Q (LC)
         .BYTE  $88,$78,$08,$08
         .BYTE  $00,$00,$B0    ; R (LC)
         .BYTE  $C8,$80,$80,$80
         .BYTE  $00,$00,$78    ; S (LC)
         .BYTE  $80,$70,$08,$F0
         .BYTE  $40,$40,$E0    ; T (LC)
         .BYTE  $40,$40,$50,$20
         .BYTE  $00,$00,$90    ; U (LC)
         .BYTE  $90,$90,$90,$68
         .BYTE  $00,$00,$88    ; V (LC)
         .BYTE  $88,$50,$50,$20
         .BYTE  $00,$00,$A8    ; W (LC)
         .BYTE  $A8,$A8,$A8,$50
         .BYTE  $00,$00,$88    ; X (LC)
         .BYTE  $50,$20,$50,$88
         .BYTE  $00,$00,$88    ; Y (LC)
         .BYTE  $50,$20,$40,$80
         .BYTE  $00,$00,$F8    ; Z (LC)
         .BYTE  $10,$20,$40,$F8
         .BYTE  $10,$20,$20    ; LEFT BRACE
         .BYTE  $60,$20,$20,$10
         .BYTE  $20,$20,$20    ; VERTICAL BAR
         .BYTE  $20,$20,$20,$20
         .BYTE  $40,$20,$20    ; RIGHT BRACE
         .BYTE  $30,$20,$20,$40
         .BYTE  $10,$A8,$40    ; TILDA
         .BYTE  $00,$00,$00,$00
         .BYTE  $A8,$50,$A8    ; RUBOUT
         .BYTE  $50,$A8,$50,$A8

END:	 .END
                        